{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FastAPI JWT Auth Features \u00b6 FastAPI extension that provides JWT Auth support (secure, easy to use and lightweight), if you were familiar with flask-jwt-extended this extension suitable for you because this extension inspired by flask-jwt-extended \ud83d\ude00 Access tokens and refresh tokens Freshness Tokens Revoking Tokens Support for adding custom claims to JSON Web Tokens Support RSA encryption Storing tokens in cookies and CSRF protection Installation \u00b6 The easiest way to start working with this extension with pip pip install fastapi-jwt-auth If you want to use asymmetric (public/private) key signing algorithms, include the asymmetric extra requirements. pip install 'fastapi-jwt-auth[asymmetric]' License \u00b6 This project is licensed under the terms of the MIT license.","title":"About"},{"location":"#features","text":"FastAPI extension that provides JWT Auth support (secure, easy to use and lightweight), if you were familiar with flask-jwt-extended this extension suitable for you because this extension inspired by flask-jwt-extended \ud83d\ude00 Access tokens and refresh tokens Freshness Tokens Revoking Tokens Support for adding custom claims to JSON Web Tokens Support RSA encryption Storing tokens in cookies and CSRF protection","title":"Features"},{"location":"#installation","text":"The easiest way to start working with this extension with pip pip install fastapi-jwt-auth If you want to use asymmetric (public/private) key signing algorithms, include the asymmetric extra requirements. pip install 'fastapi-jwt-auth[asymmetric]'","title":"Installation"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"api-doc/","text":"In here you will find the API for everything exposed in this extension. Configuring FastAPI JWT Auth \u00b6 load_config (callback) This decorator sets the callback function to overwrite state on AuthJWT class so when you initialize an instance in dependency injection default value will be overwritten. Hint : The callback must be a function that returns a list of tuple or pydantic object. token_in_denylist_loader (callback) This decorator sets the callback function that will be called when a protected endpoint is accessed and will check if the JWT has been been revoked. By default, this callback is not used. Hint : The callback must be a function that takes one argument, which is the decoded JWT (python dictionary), and returns True if the token has been revoked, or False otherwise. Protected Endpoint \u00b6 jwt_required () If you call this function, it will ensure that the requester has a valid access token before executing the code below your router. This does not check the freshness of the access token. jwt_optional () If an access token present in the request, this will call the endpoint with get_jwt_identity() having the identity of the access token. If no access token is present in the request, this endpoint will still be called, but get_jwt_identity() will return None instead. If there is an invalid access token in the request (expired, tampered with, etc), this will still call the appropriate error handler. jwt_refresh_token_required () If you call this function, it will ensure that the requester has a valid refresh token before executing the code below your router. fresh_jwt_required () If you call this function, it will ensure that the requester has a valid and fresh access token before executing the code below your router. Utilities \u00b6 create_access_token (subject, fresh=False, algorithm=None, headers=None, expires_time=None, audience=None, user_claims={}) Create a new access token. Parameters: subject : Identifier for who this token is for example id or username from database fresh : Identify token is fresh or non-fresh algorithm : Algorithm allowed to encode the token headers : Valid dict for specifying additional headers in JWT header section expires_time : Set the duration of the JWT audience : Expected audience in the JWT user_claims : Custom claims to include in this token. This data must be dictionary Returns: An encoded access token create_refresh_token (subject, algorithm=None, headers=None, expires_time=None, audience=None, user_claims={}) Creates a new refresh token. Parameters: subject : Identifier for who this token is for example id or username from database algorithm : Algorithm allowed to encode the token headers : Valid dict for specifying additional headers in JWT header section expires_time : Set the duration of the JWT audience : Expected audience in the JWT user_claims : Custom claims to include in this token. This data must be dictionary Returns: An encoded refresh token set_access_cookies (encoded_access_token, max_age=None) Configures the response to set access token in a cookie. This will also set the CSRF double submit values in a separate cookie. Parameters: encoded_access_token : The encoded access token to set in the cookies max_age : The max age of the cookie value should be integer the number of seconds Returns: None set_refresh_cookies (encoded_refresh_token, max_age=None) Configures the response to set refresh token in a cookie. This will also set the CSRF double submit values in a separate cookie. Parameters: encoded_refresh_token : The encoded refresh token to set in the cookies max_age : The max age of the cookie value should be integer the number of seconds Returns: None unset_jwt_cookies () Unset (delete) all jwt stored in a cookies. unset_access_cookies () Remove access token and access CSRF double submit from the response cookies. unset_refresh_cookies () Remove refresh token and refresh CSRF double submit from the response cookies. get_raw_jwt () This will return the python dictionary which has all of the claims of the JWT that is accessing the endpoint. If no JWT is currently present, return None instead. get_jti (encoded_token) Returns the JTI (unique identifier) of an encoded JWT Parameters: encoded_token : The encoded JWT from parameter Returns: String of JTI get_jwt_subject () This will return the subject of the JWT that is accessing the endpoint. If no JWT is present, None is returned instead. get_unverified_jwt_headers (encoded_token=None) Returns the Headers of an encoded JWT without verifying the actual signature of JWT. Parameters: encoded_token : The encoded JWT to get the Header from protected endpoint or from parameter Returns: JWT header parameters as a dictionary","title":"API Documentation"},{"location":"api-doc/#configuring-fastapi-jwt-auth","text":"load_config (callback) This decorator sets the callback function to overwrite state on AuthJWT class so when you initialize an instance in dependency injection default value will be overwritten. Hint : The callback must be a function that returns a list of tuple or pydantic object. token_in_denylist_loader (callback) This decorator sets the callback function that will be called when a protected endpoint is accessed and will check if the JWT has been been revoked. By default, this callback is not used. Hint : The callback must be a function that takes one argument, which is the decoded JWT (python dictionary), and returns True if the token has been revoked, or False otherwise.","title":"Configuring FastAPI JWT Auth"},{"location":"api-doc/#protected-endpoint","text":"jwt_required () If you call this function, it will ensure that the requester has a valid access token before executing the code below your router. This does not check the freshness of the access token. jwt_optional () If an access token present in the request, this will call the endpoint with get_jwt_identity() having the identity of the access token. If no access token is present in the request, this endpoint will still be called, but get_jwt_identity() will return None instead. If there is an invalid access token in the request (expired, tampered with, etc), this will still call the appropriate error handler. jwt_refresh_token_required () If you call this function, it will ensure that the requester has a valid refresh token before executing the code below your router. fresh_jwt_required () If you call this function, it will ensure that the requester has a valid and fresh access token before executing the code below your router.","title":"Protected Endpoint"},{"location":"api-doc/#utilities","text":"create_access_token (subject, fresh=False, algorithm=None, headers=None, expires_time=None, audience=None, user_claims={}) Create a new access token. Parameters: subject : Identifier for who this token is for example id or username from database fresh : Identify token is fresh or non-fresh algorithm : Algorithm allowed to encode the token headers : Valid dict for specifying additional headers in JWT header section expires_time : Set the duration of the JWT audience : Expected audience in the JWT user_claims : Custom claims to include in this token. This data must be dictionary Returns: An encoded access token create_refresh_token (subject, algorithm=None, headers=None, expires_time=None, audience=None, user_claims={}) Creates a new refresh token. Parameters: subject : Identifier for who this token is for example id or username from database algorithm : Algorithm allowed to encode the token headers : Valid dict for specifying additional headers in JWT header section expires_time : Set the duration of the JWT audience : Expected audience in the JWT user_claims : Custom claims to include in this token. This data must be dictionary Returns: An encoded refresh token set_access_cookies (encoded_access_token, max_age=None) Configures the response to set access token in a cookie. This will also set the CSRF double submit values in a separate cookie. Parameters: encoded_access_token : The encoded access token to set in the cookies max_age : The max age of the cookie value should be integer the number of seconds Returns: None set_refresh_cookies (encoded_refresh_token, max_age=None) Configures the response to set refresh token in a cookie. This will also set the CSRF double submit values in a separate cookie. Parameters: encoded_refresh_token : The encoded refresh token to set in the cookies max_age : The max age of the cookie value should be integer the number of seconds Returns: None unset_jwt_cookies () Unset (delete) all jwt stored in a cookies. unset_access_cookies () Remove access token and access CSRF double submit from the response cookies. unset_refresh_cookies () Remove refresh token and refresh CSRF double submit from the response cookies. get_raw_jwt () This will return the python dictionary which has all of the claims of the JWT that is accessing the endpoint. If no JWT is currently present, return None instead. get_jti (encoded_token) Returns the JTI (unique identifier) of an encoded JWT Parameters: encoded_token : The encoded JWT from parameter Returns: String of JTI get_jwt_subject () This will return the subject of the JWT that is accessing the endpoint. If no JWT is present, None is returned instead. get_unverified_jwt_headers (encoded_token=None) Returns the Headers of an encoded JWT without verifying the actual signature of JWT. Parameters: encoded_token : The encoded JWT to get the Header from protected endpoint or from parameter Returns: JWT header parameters as a dictionary","title":"Utilities"},{"location":"contributing/","text":"Sharing feedback \u00b6 This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments . If you want to contribute thankss a lot , you can open an issue on Github. Developing \u00b6 If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment. Virtual environment with venv \u00b6 You can create a virtual environment in a directory using Python's venv module: $ python3 -m venv env That will create a directory ./env/ with the Python binaries and then you will be able to install packages for that isolated environment. Activate the environment \u00b6 $ source ./env/bin/activate To check it worked, use: $ which pip some/directory/fastapi-jwt-auth/env/bin/pip If it shows the pip binary at env/bin/pip then it worked. \ud83c\udf89 Tip Every time you install a new package with pip under that environment, activate the environment again. This makes sure that if you use a terminal program installed by that package (like flit ), you use the one from your local environment and not any other that could be installed globally. Flit \u00b6 FastAPI JWT Auth uses Flit to build, package and publish the project. After activating the environment as described above, install flit : $ pip install flit Now re-activate the environment to make sure you are using the flit you just installed (and not a global one). And now use flit to install the development dependencies: $ flit install --deps develop --symlink It will install all the dependencies and your local FastAPI JWT Auth in your local environment. Using your local FastAPI JWT Auth If you create a Python file that imports and use FastAPI JWT Auth, and run it with the Python from your local environment, it will use your localFastAPI JWT Auth source code. And if you update that local FastAPI JWT Auth source code, as it is installed with --symlink , when you run that Python file again, it will use the fresh version of FastAPI JWT Auth you just edited. That way, you don't have to \"install\" your local version to be able to test every change. Docs \u00b6 The documentation uses MkDocs . All the documentation is in Markdown format in the directory ./docs . Many of the sections in the User Guide have blocks of code. In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./examples/ directory. And those Python files are included/injected in the documentation when generating the site. Docs for tests \u00b6 Most of the tests actually run against the example source files in the documentation. This helps making sure that: The documentation is up to date. The documentation examples can be run as is. Most of the features are covered by the documentation, ensured by test coverage. During local development, there is a script that builds the site and checks for any changes, live-reloading: $ bash scripts/docs-live.sh It will serve the documentation on http://0.0.0.0:5000 . That way, you can edit the documentation/source files and see the changes live. Tests \u00b6 There is a script that you can run locally to test all the code and generate coverage reports in HTML: $ bash scripts/tests.sh This command generates a directory ./htmlcov/ , if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.","title":"Development - Contributing"},{"location":"contributing/#sharing-feedback","text":"This project is still quite new and therefore having your feedback will really help to prioritize relevant feature developments . If you want to contribute thankss a lot , you can open an issue on Github.","title":"Sharing feedback"},{"location":"contributing/#developing","text":"If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment.","title":"Developing"},{"location":"contributing/#virtual-environment-with-venv","text":"You can create a virtual environment in a directory using Python's venv module: $ python3 -m venv env That will create a directory ./env/ with the Python binaries and then you will be able to install packages for that isolated environment.","title":"Virtual environment with venv"},{"location":"contributing/#activate-the-environment","text":"$ source ./env/bin/activate To check it worked, use: $ which pip some/directory/fastapi-jwt-auth/env/bin/pip If it shows the pip binary at env/bin/pip then it worked. \ud83c\udf89 Tip Every time you install a new package with pip under that environment, activate the environment again. This makes sure that if you use a terminal program installed by that package (like flit ), you use the one from your local environment and not any other that could be installed globally.","title":"Activate the environment"},{"location":"contributing/#flit","text":"FastAPI JWT Auth uses Flit to build, package and publish the project. After activating the environment as described above, install flit : $ pip install flit Now re-activate the environment to make sure you are using the flit you just installed (and not a global one). And now use flit to install the development dependencies: $ flit install --deps develop --symlink It will install all the dependencies and your local FastAPI JWT Auth in your local environment. Using your local FastAPI JWT Auth If you create a Python file that imports and use FastAPI JWT Auth, and run it with the Python from your local environment, it will use your localFastAPI JWT Auth source code. And if you update that local FastAPI JWT Auth source code, as it is installed with --symlink , when you run that Python file again, it will use the fresh version of FastAPI JWT Auth you just edited. That way, you don't have to \"install\" your local version to be able to test every change.","title":"Flit"},{"location":"contributing/#docs","text":"The documentation uses MkDocs . All the documentation is in Markdown format in the directory ./docs . Many of the sections in the User Guide have blocks of code. In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./examples/ directory. And those Python files are included/injected in the documentation when generating the site.","title":"Docs"},{"location":"contributing/#docs-for-tests","text":"Most of the tests actually run against the example source files in the documentation. This helps making sure that: The documentation is up to date. The documentation examples can be run as is. Most of the features are covered by the documentation, ensured by test coverage. During local development, there is a script that builds the site and checks for any changes, live-reloading: $ bash scripts/docs-live.sh It will serve the documentation on http://0.0.0.0:5000 . That way, you can edit the documentation/source files and see the changes live.","title":"Docs for tests"},{"location":"contributing/#tests","text":"There is a script that you can run locally to test all the code and generate coverage reports in HTML: $ bash scripts/tests.sh This command generates a directory ./htmlcov/ , if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.","title":"Tests"},{"location":"release-notes/","text":"0.3.0 \u00b6 (Deprecated) environment variable support Change name function load_end() -> load_config() Change name function get_jwt_identity() -> get_jwt_subject() Change name identity claims to standard claims sub (Thanks to @rassie for suggestion) Additional headers in claims Get additional headers claims from request or parsing token directly Leeway exp claim decode token Dynamic token expires time Change name blacklist -> denylist Denylist custom check refresh and access tokens Issuer claim Audience claim Jwt decode algorithms Dynamic algorithm create token Token multiple location Support RSA encryption (Thanks to @jet10000 for make issues) Custom header name and type Custom error message key and status code JWT in cookies (Thanks to @m4nuC for make issues) Add Additional claims Add Documentation ( #9 by @paulussimanjuntak ) 0.2.0 \u00b6 Call create_token and get_jti function must be from dependency injection Improve blacklist loader Can load env from pydantic Add docs on readme how to use without dependency injection and example on multiple files Fix raise jwt exception PR #1 by @ironslob 0.1.0 \u00b6 Initial release.","title":"Release Notes"},{"location":"release-notes/#030","text":"(Deprecated) environment variable support Change name function load_end() -> load_config() Change name function get_jwt_identity() -> get_jwt_subject() Change name identity claims to standard claims sub (Thanks to @rassie for suggestion) Additional headers in claims Get additional headers claims from request or parsing token directly Leeway exp claim decode token Dynamic token expires time Change name blacklist -> denylist Denylist custom check refresh and access tokens Issuer claim Audience claim Jwt decode algorithms Dynamic algorithm create token Token multiple location Support RSA encryption (Thanks to @jet10000 for make issues) Custom header name and type Custom error message key and status code JWT in cookies (Thanks to @m4nuC for make issues) Add Additional claims Add Documentation ( #9 by @paulussimanjuntak )","title":"0.3.0"},{"location":"release-notes/#020","text":"Call create_token and get_jti function must be from dependency injection Improve blacklist loader Can load env from pydantic Add docs on readme how to use without dependency injection and example on multiple files Fix raise jwt exception PR #1 by @ironslob","title":"0.2.0"},{"location":"release-notes/#010","text":"Initial release.","title":"0.1.0"},{"location":"configuration/cookies/","text":"These are only applicable if authjwt_token_location is use cookies. authjwt_access_cookie_key The key of the cookie that holds the access token. Defaults to access_token_cookie authjwt_refresh_cookie_key The key of the cookie that holds the refresh token. Defaults to refresh_token_cookie authjwt_access_cookie_path What path should be set for the access cookie. Defaults to '/' , which will cause this access cookie to be sent in with every request. authjwt_refresh_cookie_path What path should be set for the refresh cookie. Defaults to '/' , which will cause this refresh cookie to be sent in with every request. authjwt_cookie_max_age If you don't set anything else, the cookie will expire when the browser is closed. Defaults to None , to prevent this set expiration to int (expressed in a number of seconds). authjwt_cookie_domain The domain can be used to specify a domain and subdomain for your cookies. Defaults to None which sets this cookie to only be readable by the domain that set it. authjwt_cookie_secure If the secure flag is True cookie can only be transmitted securely over HTTPS, and it will not be sent over unencrypted HTTP connections. Defaults to False , but in production this should likely be set to True authjwt_cookie_samesite The browser sends the cookie with both cross-site and same-site requests. Set to 'lax' in production to improve protection for CSRF attacks. Defaults to None , which means cookies are always sent through external or internal site.","title":"Cookies Options"},{"location":"configuration/csrf/","text":"authjwt_cookie_csrf_protect Enable/disable CSRF protection when using cookies. Defaults to True authjwt_access_csrf_cookie_key Key of the CSRF access cookie. Defaults to 'csrf_access_token' authjwt_refresh_csrf_cookie_key Key of the CSRF refresh cookie. Defaults to 'csrf_refresh_token' authjwt_access_csrf_cookie_path Path for the CSRF access cookie. Defaults to '/' authjwt_refresh_csrf_cookie_path Path for the CSRF refresh cookie. Defaults to '/' authjwt_access_csrf_header_name Name of the header that should contain the CSRF double submit value for access tokens. Defaults to X-CSRF-TOKEN authjwt_refresh_csrf_header_name Name of the header that should contains the CSRF double submit value for refresh tokens. Defaults to X-CSRF-TOKEN authjwt_csrf_methods The request methods that will use CSRF protection. Defaults to {'POST','PUT','PATCH','DELETE'}","title":"CSRF Options"},{"location":"configuration/denylist/","text":"authjwt_denylist_enabled Enable/disable token revoking. Defaults to False authjwt_denylist_token_checks What token types to check against the denylist. The options are access or refresh . You can pass in a sequence to check more than one type. Defaults to {'access', 'refresh'} . Only used if deny listing is enabled.","title":"Denylist Options"},{"location":"configuration/general/","text":"authjwt_token_location Where to look for a JWT when processing a request. The options are headers or cookies . You can pass in a sequence to set more than one location ('headers','cookies') . Defaults to {'headers'} if you pass headers and cookies, headers are precedence. authjwt_secret_key The secret key needed for symmetric based signing algorithms, such as HS* . Defaults to None authjwt_public_key The public key needed for asymmetric based signing algorithms, such as RS* or ES* . PEM format expected. Defaults to None authjwt_private_key The private key needed for asymmetric based signing algorithms, such as RS* or ES* . PEM format expected. Defaults to None authjwt_algorithm Which algorithm to sign the JWT with. See here for the options. Defaults to HS256 authjwt_decode_algorithms Which algorithms are allowed to decode a JWT. Defaults to a list with only the algorithm set in authjwt_algorithm authjwt_decode_leeway Define the leeway part of the expiration time definition, which means you can validate an expiration time which is in the past but not very far. Defaults to 0 authjwt_encode_issuer Define the issuer to set the issuer in JWT claims, only access token have issuer claim. Defaults to None authjwt_decode_issuer Define the issuer to check the issuer in JWT claims, only access token have issuer claim. Defaults to None authjwt_decode_audience The audience or list of audiences you expect in a JWT when decoding it. Defaults to None authjwt_access_token_expires How long an access token should live before it expires. This takes value integer (seconds) or datetime.timedelta , and defaults to 15 minutes . Can be set to False to disable expiration. authjwt_refresh_token_expires How long an refresh token should live before it expires. This takes value integer (seconds) or datetime.timedelta , and defaults to 30 days . Can be set to False to disable expiration.","title":"General Options"},{"location":"configuration/headers/","text":"These are only applicable if authjwt_token_location is use headers. authjwt_header_name What header to look for the JWT in a request. Defaults to Authorization authjwt_header_type What type of header the JWT is in. Defaults to Bearer . This can be an empty string, in which case the header contains only the JWT instead like HeaderName: Bearer <JWT>","title":"Headers Options"},{"location":"usage/basic/","text":"Create a file basic.py : from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str # in production you can use Settings management # from pydantic to get secret key from .env class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" # callback to get your configuration @AuthJWT . load_config def get_config (): return Settings () # exception handler for authjwt # in production, you can tweak performance using orjson response @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) # provide a method to create access tokens. The create_access_token() # function is used to actually generate the token to use authorization # later in endpoint protected @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" and user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # subject identifier for who this token is for example id or username from database access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } # protect endpoint with function jwt_required(), which requires # a valid access token in the request headers to access. @app . get ( '/user' ) def user ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user } Run the server with: $ uvicorn basic:app --host 0 .0.0.0 INFO: Started server process [ 9859 ] INFO: Waiting for application startup. INFO: Application startup complete. INFO: Uvicorn running on http://0.0.0.0:8000 ( Press CTRL+C to quit ) To access a jwt_required protected url, all we have to do is send in the JWT with the request. By default, this is done with an authorization header that looks like: Authorization: Bearer <access_token> We can see this in action using curl : $ curl http://localhost:8000/user { \"detail\" : \"Missing Authorization Header\" } $ curl -H \"Content-Type: application/json\" -X POST \\ -d '{\"username\":\"test\",\"password\":\"test\"}' http://localhost:8000/login { \"access_token\" : \"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0IiwiaWF0IjoxNjAzNjkyMjYxLCJuYmYiOjE2MDM2OTIyNjEsImp0aSI6IjZiMjZkZTkwLThhMDYtNDEzMy04MzZiLWI5ODJkZmI3ZjNmZSIsImV4cCI6MTYwMzY5MzE2MSwidHlwZSI6ImFjY2VzcyIsImZyZXNoIjpmYWxzZX0.ro5JMHEVuGOq2YsENkZigSpqMf5cmmgPP8odZfxrzJA\" } $ export TOKEN = eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ0ZXN0IiwiaWF0IjoxNjAzNjkyMjYxLCJuYmYiOjE2MDM2OTIyNjEsImp0aSI6IjZiMjZkZTkwLThhMDYtNDEzMy04MzZiLWI5ODJkZmI3ZjNmZSIsImV4cCI6MTYwMzY5MzE2MSwidHlwZSI6ImFjY2VzcyIsImZyZXNoIjpmYWxzZX0.ro5JMHEVuGOq2YsENkZigSpqMf5cmmgPP8odZfxrzJA $ curl -H \"Authorization: Bearer $TOKEN \" http://localhost:8000 { \"user\" : \"test\" }","title":"Basic Usage"},{"location":"usage/freshness/","text":"The fresh tokens pattern is built into this extension. This pattern is very simple, you can choose to mark some access tokens as fresh and other as a non-fresh tokens, and use the fresh_jwt_required() function to only allow fresh tokens to access the certain endpoint. This is useful for allowing the fresh tokens to do some critical things (such as update information user) in real case you can see in the GitHub system when user wants to delete a repository in a certain time you need login if tokens not fresh again. Utilizing Fresh tokens in conjunction with refresh tokens can lead to a more secure site, without creating a bad user experience by making users constantly re-authenticate. Here is an example of how you could utilize refresh tokens with the fresh token pattern: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) # Standard login endpoint. Will return a fresh access token and a refresh token @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" and user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) \"\"\" create_access_token supports an optional 'fresh' argument, which marks the token as fresh or non-fresh accordingly. As we just verified their username and password, we are going to mark the token as fresh here. \"\"\" access_token = Authorize . create_access_token ( subject = user . username , fresh = True ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): \"\"\" Refresh token endpoint. This will generate a new access token from the refresh token, but will mark that access token as non-fresh, as we do not actually verify a password in this endpoint. \"\"\" Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user , fresh = False ) return { \"access_token\" : new_access_token } @app . post ( '/fresh-login' ) def fresh_login ( user : User , Authorize : AuthJWT = Depends ()): \"\"\" Fresh login endpoint. This is designed to be used if we need to make a fresh token for a user (by verifying they have the correct username and password). Unlike the standard login endpoint, this will only return a new access token, so that we don't keep generating new refresh tokens, which entirely defeats their point. \"\"\" if user . username != \"test\" and user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) new_access_token = Authorize . create_access_token ( subject = user . username , fresh = True ) return { \"access_token\" : new_access_token } # Any valid JWT access token can access this endpoint @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user } # Only fresh JWT access token can access this endpoint @app . get ( '/protected-fresh' ) def protected_fresh ( Authorize : AuthJWT = Depends ()): Authorize . fresh_jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user }","title":"Freshness Tokens"},{"location":"usage/jwt-in-cookies/","text":"Highly recommended using JWT in cookies, if your frontend interacts with the backend, your frontend may be storing JWT in the browser localStorage or sessionStorage. There is nothing wrong with this, but if you have any sort of XSS vulnerability on your site, an attacker will be able to trivially steal your tokens. If you want some additional security on your site, you can save your JWT in an httponly cookies. Which keeps javascript cannot be able to access the cookies. Here is a basic example of how to store JWT in cookies: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel \"\"\" Note: This is just a basic example how to enable cookies. This is vulnerable to CSRF attacks, and should not be used this example. \"\"\" app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" # Configure application to store and get JWT from cookies authjwt_token_location : set = { \"cookies\" } # Disable CSRF Protection for this example. default is True authjwt_cookie_csrf_protect : bool = False @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" and user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # Create the tokens and passing to set_access_cookies or set_refresh_cookies access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) # Set the JWT cookies in the response Authorize . set_access_cookies ( access_token ) Authorize . set_refresh_cookies ( refresh_token ) return { \"msg\" : \"Successfully login\" } @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) # Set the JWT cookies in the response Authorize . set_access_cookies ( new_access_token ) return { \"msg\" : \"The token has been refresh\" } @app . delete ( '/logout' ) def logout ( Authorize : AuthJWT = Depends ()): \"\"\" Because the JWT are stored in an httponly cookie now, we cannot log the user out by simply deleting the cookies in the frontend. We need the backend to send us a response to delete the cookies. \"\"\" Authorize . jwt_required () Authorize . unset_jwt_cookies () return { \"msg\" : \"Successfully logout\" } @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): \"\"\" We do not need to make any changes to our protected endpoints. They will all still function the exact same as they do when sending the JWT in via a headers instead of a cookies \"\"\" Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user } This isn't the full story. However now we can keep our cookies from being stolen via XSS attacks, but session cookies vulnerable to CSRF attacks. To combat CSRF attacks we are going to use a technique called double submit cookie pattern. Double submitting cookies is defined as sending a random value in both a cookie and as a request parameter, with the server verifying if the cookie value and request value are equal. Double Submit Cookie Pattern This tokens is saved in a cookie with httponly set to True, so it cannot be accessed via javascript. We will then create a secondary cookie that contains an only random string, but has httponly set to False so that it can be accessed via javascript running on your website. Now in order to access a protected endpoint, you will need to add a custom header that contains the random string in it, and if that header doesn\u2019t exist or it doesn\u2019t match the string that is stored in the JWT, the requester will be kicked out as unauthorized. To break this down, if an attacker attempts to perform a CSRF attack they will send the JWT (via cookie) to protected endpoint, but without the random string in the request headers, they won't be able to access the endpoint. They cannot access the random string unless they can run javascript on your website likely via an XSS attack , and if they are able to perform an XSS attack, they will not be able to steal the actual access and refresh JWT, as javascript is still not able to access those httponly cookies. No system is safe. If an attacker can perform an XSS attack they can still access protected endpoints from people who visit your site. However, it is better than if they were able to steal the access and refresh tokens from local/session storage, and use them whenever they wanted. Here is an example of using cookies with CSRF protection: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel \"\"\" By default, the CRSF cookies will be called csrf_access_token and csrf_refresh_token, and in protected endpoints we will look for the CSRF token in the 'X-CSRF-Token' headers. only certain methods should define CSRF token in headers default is ('POST','PUT','PATCH','DELETE') \"\"\" app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" # Configure application to store and get JWT from cookies authjwt_token_location : set = { \"cookies\" } # Only allow JWT cookies to be sent over https authjwt_cookie_secure : bool = False # Enable csrf double submit protection. default is True authjwt_cookie_csrf_protect : bool = True # Change to 'lax' in production to make your website more secure from CSRF Attacks, default is None # authjwt_cookie_samesite: str = 'lax' @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): \"\"\" With authjwt_cookie_csrf_protect set to True, set_access_cookies() and set_refresh_cookies() will now also set the non-httponly CSRF cookies \"\"\" if user . username != \"test\" and user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # Create the tokens and passing to set_access_cookies or set_refresh_cookies access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) # Set the JWT and CSRF double submit cookies in the response Authorize . set_access_cookies ( access_token ) Authorize . set_refresh_cookies ( refresh_token ) return { \"msg\" : \"Successfully login\" } @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) # Set the JWT and CSRF double submit cookies in the response Authorize . set_access_cookies ( new_access_token ) return { \"msg\" : \"The token has been refresh\" } @app . delete ( '/logout' ) def logout ( Authorize : AuthJWT = Depends ()): \"\"\" Because the JWT are stored in an httponly cookie now, we cannot log the user out by simply deleting the cookie in the frontend. We need the backend to send us a response to delete the cookies. \"\"\" Authorize . jwt_required () Authorize . unset_jwt_cookies () return { \"msg\" : \"Successfully logout\" } @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user }","title":"JWT in Cookies"},{"location":"usage/optional/","text":"In some cases you want to use one endpoint for both, protected and unprotected. In this situation you can use function jwt_optional() . This will allow the endpoint to be accessed regardless of if a JWT is sent in the request or not. If a JWT get tampering or expired an error will be returned instead of calling the endpoint. from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" and user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) return { \"access_token\" : access_token } @app . get ( '/partially-protected' ) def partially_protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_optional () # If no jwt is sent in the request, get_jwt_subject() will return None current_user = Authorize . get_jwt_subject () or \"anonymous\" return { \"user\" : current_user }","title":"Partially Protecting"},{"location":"usage/refresh/","text":"These are long-lived tokens which can be used to create a new access tokens once an old access token has expired. Refresh tokens cannot access an endpoint that is protected with jwt_required() , jwt_optional() , and fresh_jwt_required() and access tokens cannot access an endpoint that is protected with jwt_refresh_token_required() . Utilizing refresh tokens we can help reduce the damage that can be done if an access tokens is stolen. However, if an attacker gets a refresh tokens they can keep generating new access tokens and accessing protected endpoints as though he was that user. We can help combat this by using the fresh tokens pattern, discussed in the next section. Here is an example of using access and refresh tokens: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" and user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) # Use create_access_token() and create_refresh_token() to create our # access and refresh tokens access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): \"\"\" The jwt_refresh_token_required() function insures a valid refresh token is present in the request before running any code below that function. we can use the get_jwt_subject() function to get the subject of the refresh token, and use the create_access_token() function again to make a new access token \"\"\" Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user }","title":"Refresh Tokens"},{"location":"usage/revoking/","text":"This will allow you to revoke a specific tokens so that it can no longer access your endpoints. You will have to choose what tokens you want to check against the denylist. Denylist works by providing a callback function to this extension, using the token_in_denylist_loader() . This method will be called whenever the specified tokens (access and/or refresh) is used to access a protected endpoint. If the callback function says that the tokens is revoked, we will not allow the requester to continue, otherwise we will allow the requester to access the endpoint as normal. Here is a basic example use tokens revoking: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel app = FastAPI () class User ( BaseModel ): username : str password : str # set denylist enabled to True # you can set to check access or refresh token or even both of them class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" authjwt_denylist_enabled : bool = True authjwt_denylist_token_checks : set = { \"access\" , \"refresh\" } @AuthJWT . load_config def get_config (): return Settings () @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) # A storage engine to save revoked tokens. in production, # you can use Redis for storage system denylist = set () # For this example, we are just checking if the tokens jti # (unique identifier) is in the denylist set. This could # be made more complex, for example storing the token in Redis # with the value true if revoked and false if not revoked @AuthJWT . token_in_denylist_loader def check_if_token_in_denylist ( decrypted_token ): jti = decrypted_token [ 'jti' ] return jti in denylist @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" and user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } # Standard refresh endpoint. Token in denylist will not # be able to access this endpoint @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } # Endpoint for revoking the current users access token @app . delete ( '/access-revoke' ) def access_revoke ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () jti = Authorize . get_raw_jwt ()[ 'jti' ] denylist . add ( jti ) return { \"detail\" : \"Access token has been revoke\" } # Endpoint for revoking the current users refresh token @app . delete ( '/refresh-revoke' ) def refresh_revoke ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () jti = Authorize . get_raw_jwt ()[ 'jti' ] denylist . add ( jti ) return { \"detail\" : \"Refresh token has been revoke\" } # A token in denylist will not be able to access this any more @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user } In production, you will likely want to use either a database or in-memory store (such as Redis) to store your tokens. Memory stores are great if you are wanting to revoke a tokens when the users log out and you can define timeout to your tokens in Redis, after the timeout has expired, the tokens will automatically be deleted. Note Before that make sure redis already installed on your local machine, you can use docker using this command docker run -d -p 6379:6379 redis Here example use Redis for revoking a tokens: from fastapi import FastAPI , HTTPException , Depends , Request from fastapi.responses import JSONResponse from fastapi_jwt_auth import AuthJWT from fastapi_jwt_auth.exceptions import AuthJWTException from pydantic import BaseModel from datetime import timedelta from redis import Redis app = FastAPI () class User ( BaseModel ): username : str password : str class Settings ( BaseModel ): authjwt_secret_key : str = \"secret\" authjwt_denylist_enabled : bool = True authjwt_denylist_token_checks : set = { \"access\" , \"refresh\" } access_expires : int = timedelta ( minutes = 15 ) refresh_expires : int = timedelta ( days = 30 ) settings = Settings () @AuthJWT . load_config def get_config (): return settings @app . exception_handler ( AuthJWTException ) def authjwt_exception_handler ( request : Request , exc : AuthJWTException ): return JSONResponse ( status_code = exc . status_code , content = { \"detail\" : exc . message } ) # Setup our redis connection for storing the denylist tokens redis_conn = Redis ( host = 'localhost' , port = 6379 , db = 0 , decode_responses = True ) # Create our function to check if a token has been revoked. In this simple # case, we will just store the tokens jti (unique identifier) in redis. # This function will return the revoked status of a token. If a token exists # in redis and value is true, token has been revoked @AuthJWT . token_in_denylist_loader def check_if_token_in_denylist ( decrypted_token ): jti = decrypted_token [ 'jti' ] entry = redis_conn . get ( jti ) return entry and entry == 'true' @app . post ( '/login' ) def login ( user : User , Authorize : AuthJWT = Depends ()): if user . username != \"test\" and user . password != \"test\" : raise HTTPException ( status_code = 401 , detail = \"Bad username or password\" ) access_token = Authorize . create_access_token ( subject = user . username ) refresh_token = Authorize . create_refresh_token ( subject = user . username ) return { \"access_token\" : access_token , \"refresh_token\" : refresh_token } # Standard refresh endpoint. Token in denylist will not # be able to access this endpoint @app . post ( '/refresh' ) def refresh ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () current_user = Authorize . get_jwt_subject () new_access_token = Authorize . create_access_token ( subject = current_user ) return { \"access_token\" : new_access_token } # Endpoint for revoking the current users access token @app . delete ( '/access-revoke' ) def access_revoke ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () # Store the tokens in redis with the value true for revoked. # We can also set an expires time on these tokens in redis, # so they will get automatically removed after they expired. jti = Authorize . get_raw_jwt ()[ 'jti' ] redis_conn . setex ( jti , settings . access_expires , 'true' ) return { \"detail\" : \"Access token has been revoke\" } # Endpoint for revoking the current users refresh token @app . delete ( '/refresh-revoke' ) def refresh_revoke ( Authorize : AuthJWT = Depends ()): Authorize . jwt_refresh_token_required () jti = Authorize . get_raw_jwt ()[ 'jti' ] redis_conn . setex ( jti , settings . refresh_expires , 'true' ) return { \"detail\" : \"Refresh token has been revoke\" } # A token in denylist will not be able to access this any more @app . get ( '/protected' ) def protected ( Authorize : AuthJWT = Depends ()): Authorize . jwt_required () current_user = Authorize . get_jwt_subject () return { \"user\" : current_user }","title":"Revoking Tokens"}]}